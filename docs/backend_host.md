# GraphyFlow Backend Documentation: Host & Build System

## 1. Introduction

Besides generating the synthesizable FPGA kernel, the GraphyFlow backend is also responsible for creating all the supporting software and scripts required to compile, run, and verify the complete application. This automated process ensures that the user receives a fully standalone and runnable Vitis project. The main components responsible for this are the `BackendManager` class and the `project_generator.py` script [cite: CCFSys2025_GraphyFlow/graphyflow/backend_manager.py, CCFSys2025_GraphyFlow/graphyflow/project_generator.py].

## 2. Host Code Generation

The host application is the C++ program that runs on the CPU. It is responsible for managing the FPGA, preparing data, transferring it to and from the device's global memory, and verifying the results. This code is dynamically generated by the `generate_host_codes` method within the `BackendManager` to match the specific data types and interfaces of the compiled kernel [cite: CCFSys2025_GraphyFlow/graphyflow/backend_manager.py].

The generation process uses a templating approach, filling in placeholders in files located in `graphyflow/project_template/scripts/host/` [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/].

### Key Generated Files and Their Responsibilities:

* **`common.h`**: This crucial header file is generated by `generate_common_header` [cite: CCFSys2025_GraphyFlow/graphyflow/backend_manager.py]. It contains all the C++ `struct` definitions derived from the Type Analysis phase. By having both the host and kernel include this file, it guarantees that the data layout in memory is identical, preventing data corruption during transfers.

* **`generated_host.cpp / .h`**: These files contain the algorithm-specific logic for the host application. The `BackendManager` populates these templates with code that handles:
    * **Buffer Management**: It declares `std::vector` containers for host-side data and corresponding `cl::Buffer` objects for the FPGA device memory.
    * **Data Packing**: It implements the logic to read the input graph (loaded by `graph_loader.cpp`) and pack it into the batched `struct` format expected by the kernel's AXI interface. For iterative algorithms like Bellman-Ford, it also includes logic to update the node `distance` values in these buffers between iterations [cite: CCFSys2025_GraphyFlow/graphyflow/backend_manager.py].
    * **Kernel Execution**: It generates the code to set the correct kernel arguments (`m_kernel.setArg(...)`) and enqueue the kernel for execution on the FPGA.
    * **Convergence Check**: For iterative algorithms, it implements the logic to migrate results back from the FPGA, unpack the reduced data, update the global distance array, and check for convergence (i.e., if any distance values changed in the last iteration) [cite: CCFSys2025_GraphyFlow/graphyflow/backend_manager.py].

## 3. Project Assembly and Build System

The final assembly of the Vitis project is orchestrated by the `generate_project` function in `graphyflow/project_generator.py` [cite: CCFSys2025_GraphyFlow/graphyflow/project_generator.py]. It combines the dynamically generated code with static template files to create a complete project directory.

### Process Steps:

1.  **Create Directory Structure**: It creates the output directory (e.g., `generated_project/`) with the standard Vitis project subdirectories like `scripts/host/`, `scripts/kernel/`, and `xclbin/` [cite: CCFSys2025_GraphyFlow/graphyflow/project_generator.py].

2.  **Copy Static Files**: It copies the generic, non-changing parts of the host application and build system from `graphyflow/project_template/`. These include:
    * `host.cpp`: The main entry point (`main` function) of the host application, which orchestrates loading the graph, running the FPGA kernel, and verifying the result [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/host.cpp].
    * `graph_loader.cpp`: A utility to parse the input `graph.txt` file into a C++ object [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/graph_loader.cpp].
    * `fpga_executor.cpp`: Manages the overall FPGA execution flow, including the iteration loop for algorithms like Bellman-Ford [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/fpga_executor.cpp].
    * `host_verifier.cpp`: Contains the CPU-based implementation of the algorithm used to verify the correctness of the FPGA results [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/host_verifier.cpp].
    * `xcl2.h / .cpp`: Standard Xilinx utilities for simplifying OpenCL API calls [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/xcl2.h, CCFSys2025_GraphyFlow/graphyflow/project_template/scripts/host/xcl2.cpp].

3.  **Generate Dynamic Build Scripts**: It generates the final build and execution scripts by replacing placeholders (like `{{KERNEL_NAME}}`) in the templates:
    * **`Makefile`**: A top-level Makefile that defines the kernel and executable names and provides simple targets like `all`, `clean`, and `check` for easy building and testing [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/Makefile].
    * **`run.sh`**: A shell script that correctly sets up the `XCL_EMULATION_MODE` environment variable and executes the compiled host binary with the appropriate `.xclbin` file for the specified target (`sw_emu`, `hw_emu`, or `hw`) [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/run.sh].
    * **`system.cfg`**: A Vitis linker configuration file that specifies the connectivity between the kernel's memory interfaces and the FPGA's global memory banks [cite: CCFSys2025_GraphyFlow/graphyflow/project_template/system.cfg].
